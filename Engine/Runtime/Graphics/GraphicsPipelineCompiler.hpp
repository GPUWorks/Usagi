#pragma once

#include <memory>
#include <string>

#include <Usagi/Engine/Utility/Noncopyable.hpp>

#include "PipelineCreateInfo.hpp"
#include "Shader/ShaderStage.hpp"
#include "Enum/GpuDataFormat.hpp"

namespace usagi
{
class RenderPass;
class SpirvBinary;
class GraphicsPipeline;
class GpuImage;

/**
 * \brief Compiles graphics pipeline from state specifications. Default states
 * are defined in corresponding state structs. Resource binding info is
 * generated by reflecting the shaders.
 */
class GraphicsPipelineCompiler : Noncopyable
{
public:
    virtual ~GraphicsPipelineCompiler() = default;

    // todo res desc set

    virtual void setRenderPass(std::shared_ptr<RenderPass> render_pass) = 0;

    virtual void setShader(
        ShaderStage stage,
        std::shared_ptr<SpirvBinary> shader) = 0;

    virtual void setVertexBufferBinding(
        std::uint32_t binding_index,
        std::uint32_t stride,
        VertexInputRate input_rate = VertexInputRate::PER_VERTEX) = 0;
    virtual void setVertexAttribute(
        std::string attr_name,
        std::uint32_t binding_index,
        std::uint32_t offset,
        GpuDataFormat source_format) = 0;
    virtual void setVertexAttribute(
        std::uint32_t attr_location,
        std::uint32_t binding_index,
        std::uint32_t offset,
        GpuDataFormat source_format) = 0;

    virtual void setInputAssemblyState(const InputAssemblyState &state) = 0;
    virtual void setRasterizationState(const RasterizationState &state) = 0;
    virtual void setDepthStencilState(const DepthStencilState &state) = 0;
    virtual void setColorBlendState(const ColorBlendState &state) = 0;

    virtual std::shared_ptr<GraphicsPipeline> compile() = 0;
};
}
