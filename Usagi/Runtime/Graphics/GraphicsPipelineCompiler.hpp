#pragma once

#include <memory>
#include <string>

#include <Usagi/Utility/Noncopyable.hpp>

#include "PipelineCreateInfo.hpp"
#include "Shader/ShaderStage.hpp"
#include "Enum/GpuBufferFormat.hpp"

namespace usagi
{
class RenderPass;
class SpirvBinary;
class GraphicsPipeline;
class GpuImage;

/**
 * \brief Compiles graphics pipeline from state specifications. Default states
 * are defined in corresponding state structs. Resource binding info is
 * generated by reflecting the shaders.
 */
class GraphicsPipelineCompiler : Noncopyable
{
public:
    virtual ~GraphicsPipelineCompiler() = default;

    // todo res desc set

    virtual void setRenderPass(std::shared_ptr<RenderPass> render_pass) = 0;

    // todo get stage from SpirvBinary/split into set{Vertex/Fragment|...}Shader
    virtual void setShader(
        ShaderStage stage,
        std::shared_ptr<SpirvBinary> shader) = 0;

    virtual void setVertexBufferBinding(
        std::uint32_t binding_index,
        std::uint32_t stride,
        VertexInputRate input_rate = VertexInputRate::PER_VERTEX) = 0;
    virtual void setVertexAttribute(
        std::string attr_name,
        std::uint32_t binding_index,
        std::uint32_t offset,
        GpuBufferFormat source_format) = 0;
    virtual void setVertexAttribute(
        std::uint32_t attr_location,
        std::uint32_t binding_index,
        std::uint32_t offset,
        GpuBufferFormat source_format) = 0;

    virtual void iaSetPrimitiveTopology(PrimitiveTopology topology) = 0;
    virtual void setInputAssemblyState(const InputAssemblyState &state) = 0;

    virtual void rsSetPolygonMode(PolygonMode mode) = 0;
    virtual void rsSetFaceCullingMode(FaceCullingMode mode) = 0;
    virtual void rsSetFrontFace(FrontFace face) = 0;
    virtual void setRasterizationState(const RasterizationState &state) = 0;

    /**
     * \brief Turn on/off depth test & write together.
     * \param enabled
     */
    virtual void omSetDepthEnabled(bool enabled) = 0;
    virtual void setDepthStencilState(const DepthStencilState &state) = 0;

    virtual void omSetColorBlendEnabled(bool enabled) = 0;
    virtual void setColorBlendState(const ColorBlendState &state) = 0;

    /**
     * \brief Create the pipeline. If called more than once, the other pipelines
     * will be the derivatives of the first one.
     * \return
     */
    virtual std::shared_ptr<GraphicsPipeline> compile() = 0;
};
}
